#pragma once
#include <sdkddkver.h>
#include <Windows.h>
#include <process.h>
#include <memory>
#include <stdexcept>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <utility>
#include <string_view>
#include <future>

namespace Alias{
	constexpr size_t COMM_TIMEOUT = 500;
	constexpr size_t READ_BUFFER_SIZE = 1028;
	constexpr size_t OUTPUT_LOOP_SLEEP_TIME_MS = 16; // millisecond
	class WindowsError : public std::logic_error{
		public:
			WindowsError(long error) : std::logic_error(
				"Something went wrong in the windows API calls. Error: " +
				std::to_string(error)) {
					// TODO integrate this code to format windows error
				/*
					auto error = GetLastError();
					LPVOID lpMsgBuf;
					LPVOID lpDisplayBuf;

					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_SYSTEM |
						FORMAT_MESSAGE_IGNORE_INSERTS,
						NULL,
						error,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(LPTSTR)&lpMsgBuf,
						0, NULL);
					std::wstring wmessage((LPTSTR)lpMsgBuf);
					std::string message;
					message.assign(wmessage.begin(), wmessage.end());
				*/
				}
			WindowsError(std::string error_message) : std::logic_error(error_message){}
			const std::string message = this->what();
	};
	class Process;
    class PseudoConsole;
	class PrimaryConsole;

	class PrimaryConsole{
		private:
			HANDLE std_in;
			HANDLE std_out;
			
		public:
			PrimaryConsole();
			~PrimaryConsole();
			void cancel_io();
			auto read_input_from_console() -> std::future<std::string>;
			auto number_of_input_events() -> size_t;
			auto write_to_stdout(std::string_view) -> size_t;
	};
    class PseudoConsole{
		private:
			std::vector<std::string> output_buffer{};
        public:
            using ptr = std::unique_ptr<PseudoConsole>;
            using Sptr = std::shared_ptr<PseudoConsole>;
			using BufferIterator = std::vector<std::string>::iterator;
			const int x;
			const int y;
            const HANDLE pipe_in;
            const HANDLE pipe_out;
            const HPCON pseudo_console_handle;
			std::string last_read_in;

			PseudoConsole() = delete;
			PseudoConsole(int x, int y, HPCON pseudoConsoleHandle, HANDLE pipeIn, HANDLE pipeOut)
			: x(x), y(y), pipe_in(pipeIn), pipe_out(pipeOut), pseudo_console_handle(pseudoConsoleHandle){}

            ~PseudoConsole(){

				ClosePseudoConsole(pseudo_console_handle);
				CloseHandle(pipe_in);
				CloseHandle(pipe_out);
            }
			auto read_output() -> BufferIterator;
			void write_input(std::string_view) const;
			[[nodiscard]] auto bytes_in_read_pipe() const -> size_t;
			auto get_output_buffer(){
				return &output_buffer;
			};
			[[nodiscard]] auto latest_output() const -> std::string{
				return last_read_in;
			}
			auto read_output_as_pair() -> std::pair<BufferIterator, BufferIterator>{
				return std::make_pair(this->read_output(), output_buffer.end());
			}
			static auto get_cursor_position_as_vt(int, int) -> std::string;
			static auto get_cursor_position_as_movement() -> std::string;
			void process_attached(Process *process);
    };
	class Process{
		public:
			using ptr = std::unique_ptr<Process>;
			const STARTUPINFOEXW startup_info;
			const PROCESS_INFORMATION process_info;

			Process(STARTUPINFOEXW startup_info, PROCESS_INFORMATION process_info) :
				startup_info(startup_info), process_info(process_info){}
			void kill(unsigned long timeout) const{
				TerminateProcess(process_info.hProcess, 0);
				WaitForSingleObject(process_info.hProcess, timeout);
			}
			[[nodiscard]] auto stopped() const -> bool;
			void wait_for_stop(unsigned long timeout) const{
				WaitForSingleObject(process_info.hThread, timeout);
			}
			~Process(){
				this->kill(INFINITE);
				CloseHandle(process_info.hThread);
				CloseHandle(process_info.hProcess);
				SetLastError(0); // Ignore any errors generated by closing
			}
	};
	void check_and_throw_error(HRESULT error) noexcept(false);
	void check_and_throw_error(std::string error_message) noexcept(false);
	void check_and_throw_error() noexcept(false);
    auto CreatePseudoConsole(int, int, int, int) noexcept(false) -> PseudoConsole::ptr;
	auto CreateStartupInfoForConsole(PseudoConsole *console) noexcept(false) -> STARTUPINFOEXW;
	auto NewProcess(PseudoConsole *console, std::wstring command_line) noexcept(false) -> Process::ptr;
	auto GetCursorInfo(HANDLE console) -> CONSOLE_SCREEN_BUFFER_INFO;
	auto CheckStdOut(std::string message) -> bool;
	auto SetupConsoleHost() -> bool;
	auto ReverseSetupConsoleHost() -> bool;
	auto Setup_Console_Stdout() -> std::string;
	auto Setup_Console_Stdin() -> std::string;
	auto Split_String(std::string_view, char, std::vector<std::string>*) -> std::vector<std::string>::iterator;
	/**
	 * Create a stdin and stdout pair based on fstreams.
	 * This causes the stdin and stdout to be eaten basically.
	 */
	auto Rebind_Std_In_Out() -> std::pair<std::fstream, std::fstream>;
	auto Get_StdIn_As_Stream() -> std::pair<std::ifstream, std::ofstream>;
}
