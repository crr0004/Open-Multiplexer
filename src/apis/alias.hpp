#pragma once
#include <SDKDDKVer.h>
#include <Windows.h>
#include <process.h>
#include <memory>
#include <stdexcept>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>

namespace Alias{
	class WindowsError : public std::logic_error{
		public:
			WindowsError(long error) : std::logic_error(
				"Something went wrong in the windows API calls. Error: " +
				std::to_string(error)) {}
			WindowsError(std::string error_message) : std::logic_error(error_message){}
			const std::string message = this->what();
	};
	class Process;
    class PseudoConsole{
		private:
			std::vector<std::shared_ptr<std::string>> output_buffer{};
        public:
            using ptr = std::unique_ptr<PseudoConsole>;
			const int x;
			const int y;
            const HANDLE pipe_in;
            const HANDLE pipe_out;
            const HPCON pseudo_console_handle;

			PseudoConsole() = delete;
			PseudoConsole(int x, int y, HPCON pseudoConsoleHandle, HANDLE pipeIn, HANDLE pipeOut)
			: x(x), y(y), pipe_in(pipeIn), pipe_out(pipeOut), pseudo_console_handle(pseudoConsoleHandle){}

            ~PseudoConsole(){

				ClosePseudoConsole(pseudo_console_handle);
				CloseHandle(pipe_in);
				CloseHandle(pipe_out);
            }
			void read_output();
			auto get_output_buffer(){
				return output_buffer;
			};
			std::shared_ptr<std::string> latest_output();
			std::string get_cursor_position_as_vt(int, int);
			size_t write(std::string, HANDLE);
			void process_attached(Process *process);
    };
	class Process{
		public:
			using ptr = std::unique_ptr<Process>;
			const STARTUPINFOEXW startup_info;
			const PROCESS_INFORMATION process_info;

			Process(auto startup_info, auto process_info) : 
				startup_info(startup_info), process_info(process_info){}
			void kill(unsigned long timeout){
				TerminateProcess(process_info.hProcess, 0);
				WaitForSingleObject(process_info.hProcess, timeout);
			}
			bool stopped();
			void wait_for_stop(unsigned long timeout){
				WaitForSingleObject(process_info.hThread, timeout);
			}
			~Process(){
				this->kill(INFINITE);
				CloseHandle(process_info.hThread);
				CloseHandle(process_info.hProcess);
				SetLastError(0); // Ignore any errors generated by closing
			}
	};
	void check_and_throw_error(HRESULT error) noexcept(false);
	void check_and_throw_error(std::string error_message) noexcept(false);
	void check_and_throw_error() noexcept(false);
    PseudoConsole::ptr CreatePseudoConsole(int, int, int, int) noexcept(false);
	STARTUPINFOEXW CreateStartupInfoForConsole(PseudoConsole *console) noexcept(false);
	Process::ptr NewProcess(PseudoConsole *console, std::wstring command_line) noexcept(false);
	CONSOLE_SCREEN_BUFFER_INFO GetCursorInfo(HANDLE console);
	bool CheckStdOut(std::string message);
	bool SetupConsoleHost() noexcept(false);
}
